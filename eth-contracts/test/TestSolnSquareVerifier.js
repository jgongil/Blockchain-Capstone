// define a variable to import the <Verifier> or <renamedVerifier> solidity contract generated by Zokrates
let SolnSquareVerifier = artifacts.require('SolnSquareVerifier');
// Proof by zokrates
let sqproof = require("../../zokrates/code/square/proof");

contract('SolnSquareVerifier', accounts => {
    const account_one = accounts[0]; // owns the contract
    const account_two = accounts[1]; // mints a new token
    const account_three = accounts[2]; // will try to mint using other´s proof
    const tokenId1 = 11;
    const proof = {
        a:sqproof.proof.a,
        b:sqproof.proof.b,
        c:sqproof.proof.c,
        inputs:sqproof.inputs
    };
    describe('SolnSquareVerifier Functionalities', function () {

        beforeEach(async function () { 
            this.contract = await SolnSquareVerifier.new({from: account_one});
        });

        // Test if a new solution can be added for contract - SolnSquareVerifier
        it('a new solution can be added for the contract by account_two', async function () {

            let result = await this.contract.addSolution(proof.a,proof.b,proof.c,proof.inputs,{from: account_two});
            //console.log(result);
            console.log("event emitted: ", result.logs[0].event);

            let readded = false;
            try{
                await this.contract.addSolution(proof.a,proof.b,proof.c,proof.inputs,{from: account_two});
                readded = true;
            }catch(e){
                readded = false;
            }
            console.log("Can readd existing solution?: ", readded);
        });

        // Test if an ERC721 token can be minted for contract - SolnSquareVerifier
        it('an ERC721 token cannot be minted if proof wasn´t provided first', async function () {
            let minted = false;
            try{
                let result = await this.contract.secureMint(account_two,tokenId1,proof.a,proof.b,proof.c,proof.inputs,{from: account_one});
                minted = true;
                console.log("event emitted: ", result.logs[0].event);
            } catch(e){
                console.log("Error while minting " + e);
                minted = false;
            }
            assert.equal(minted,false,"Could mint without providing proof");

        });

        it('an ERC721 token can be minted for contract if proof was provided and is still valid', async function () {
            let minted = false;
            try{
                await this.contract.addSolution(proof.a,proof.b,proof.c,proof.inputs,{from: account_two});
                let result = await this.contract.secureMint(account_two,tokenId1,proof.a,proof.b,proof.c,proof.inputs,{from: account_one});
                console.log("event emitted: ", result.logs[0].event);
                minted = true;
            } catch(e){
                console.log("Error while minting " + e);
                minted = false;
            }
            assert.equal(minted,true,"Couldn´t mint with a valid proof");   
        });

        it('an ERC721 token cannot be minted using other´s proof', async function () {
            let minted = false;
            try{
                await this.contract.addSolution(proof.a,proof.b,proof.c,proof.inputs,{from: account_two});
                // account_three tries to mint with account_two proof
                let result = await this.contract.secureMint(account_three,tokenId1,proof.a,proof.b,proof.c,proof.inputs,{from: account_one});
                console.log("event emitted: ", result.logs[0].event);
                minted = true;
            } catch(e){
                console.log("Error while minting " + e);
                minted = false;
            }
            assert.equal(minted,false,"Could mint with other´s proof");   
        });

    });

});




